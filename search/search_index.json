{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"material-sphinx Autodoc with material-for-mkdocs . This project is a fork of keras-autodoc , with updates made for Sphinx >= 4.0. material-sphinx will fetch the docstrings from the functions you wish to document and will insert them in the markdown files. Install First, create a conda or virtual environment, activate it, and run: pip install git+https://github.com/JustinGoheen/material-sphinx.git Example see instructions for creating your site provided by material-for-mkdocs to create the proper directory structure. Let's suppose that you have a project with a docs directory: /project-root |--/source_code __init__.py main.py |--./docs autogen.py mkdocs.yml setup.py The API is quite simple: # content of docs/autogen.py from material_sphinx import DocumentationGenerator pages = {'layers/core.md': ['keras.layers.Dense', 'keras.layers.Flatten'], 'callbacks.md': ['keras.callbacks.TensorBoard']} doc_generator = DocumentationGenerator(pages) doc_generator.generate('./sources') # content of docs/mkdocs.yml site_name: My_site docs_dir: docs/sources site_description: 'My pretty site.' nav: - Core: layers/core.md - Callbacks: - Some callbacks: callbacks.md Then you just have to run: python docs/autogen.py mkdocs serve and you'll be able to see your website at localhost:8000/callbacks . Docstring format: The docstrings used should use the Google docstring style, found in the Google Python Style Guide with markdown, or just plain markdown. Deploying your site See the instructions for deploying your site provided by material-for-mkdocs.","title":"Home"},{"location":"#material-sphinx","text":"Autodoc with material-for-mkdocs . This project is a fork of keras-autodoc , with updates made for Sphinx >= 4.0. material-sphinx will fetch the docstrings from the functions you wish to document and will insert them in the markdown files.","title":"material-sphinx"},{"location":"#install","text":"First, create a conda or virtual environment, activate it, and run: pip install git+https://github.com/JustinGoheen/material-sphinx.git","title":"Install"},{"location":"#example","text":"see instructions for creating your site provided by material-for-mkdocs to create the proper directory structure. Let's suppose that you have a project with a docs directory: /project-root |--/source_code __init__.py main.py |--./docs autogen.py mkdocs.yml setup.py The API is quite simple: # content of docs/autogen.py from material_sphinx import DocumentationGenerator pages = {'layers/core.md': ['keras.layers.Dense', 'keras.layers.Flatten'], 'callbacks.md': ['keras.callbacks.TensorBoard']} doc_generator = DocumentationGenerator(pages) doc_generator.generate('./sources') # content of docs/mkdocs.yml site_name: My_site docs_dir: docs/sources site_description: 'My pretty site.' nav: - Core: layers/core.md - Callbacks: - Some callbacks: callbacks.md Then you just have to run: python docs/autogen.py mkdocs serve and you'll be able to see your website at localhost:8000/callbacks .","title":"Example"},{"location":"#docstring-format","text":"The docstrings used should use the Google docstring style, found in the Google Python Style Guide with markdown, or just plain markdown.","title":"Docstring format:"},{"location":"#deploying-your-site","text":"See the instructions for deploying your site provided by material-for-mkdocs.","title":"Deploying your site"},{"location":"automatic_gathering/","text":"[source] get_functions material_sphinx.get_functions(module, exclude=None, return_strings=True) Get all the functions of a module. Arguments module : The module to fetch the functions from. If it's a string, it should be in the dotted format. 'keras.backend' for example. exclude Optional[List[str]] : The names which will be excluded from the returned list. For example, get_functions('keras.backend', exclude=['max']) . return_strings bool : If False, the actual functions will be returned. Note that if you use aliases when building your docs, you should use strings. This is because the computed signature uses __name__ and __module__ if you don't provide a string as input. Returns A list of strings or a list of functions. [source] get_classes material_sphinx.get_classes(module, exclude=None, return_strings=True) Get all the classes of a module. Arguments module : The module to fetch the classes from. If it's a string, it should be in the dotted format. 'keras.layers' for example. exclude Optional[List[str]] : The names which will be excluded from the returned list. For example, get_classes('keras.layers', exclude=['Dense', 'Conv2D']) . return_strings bool : If False, the actual classes will be returned. Note that if you use aliases when building your docs, you should use strings. This is because the computed signature uses __name__ and __module__ if you don't provide a string as input. Returns A list of strings or a list of classes. [source] get_methods material_sphinx.get_methods(cls, exclude=None, return_strings=True) Get all the method of a class. Arguments cls : The class to fetch the methods from. If it's a string, it should be in the dotted format. 'keras.layers.Dense' for example. exclude : The names which will be excluded from the returned list. For example, get_methods('keras.Model', exclude=['save']) . return_strings : If False, the actual methods will be returned. Note that if you use aliases when building your docs, you should use strings. This is because the computed signature uses __name__ and __module__ if you don't provide a string as input. Returns A list of strings or a list of methods.","title":"Automatic gathering"},{"location":"automatic_gathering/#get_functions","text":"material_sphinx.get_functions(module, exclude=None, return_strings=True) Get all the functions of a module. Arguments module : The module to fetch the functions from. If it's a string, it should be in the dotted format. 'keras.backend' for example. exclude Optional[List[str]] : The names which will be excluded from the returned list. For example, get_functions('keras.backend', exclude=['max']) . return_strings bool : If False, the actual functions will be returned. Note that if you use aliases when building your docs, you should use strings. This is because the computed signature uses __name__ and __module__ if you don't provide a string as input. Returns A list of strings or a list of functions. [source]","title":"get_functions"},{"location":"automatic_gathering/#get_classes","text":"material_sphinx.get_classes(module, exclude=None, return_strings=True) Get all the classes of a module. Arguments module : The module to fetch the classes from. If it's a string, it should be in the dotted format. 'keras.layers' for example. exclude Optional[List[str]] : The names which will be excluded from the returned list. For example, get_classes('keras.layers', exclude=['Dense', 'Conv2D']) . return_strings bool : If False, the actual classes will be returned. Note that if you use aliases when building your docs, you should use strings. This is because the computed signature uses __name__ and __module__ if you don't provide a string as input. Returns A list of strings or a list of classes. [source]","title":"get_classes"},{"location":"automatic_gathering/#get_methods","text":"material_sphinx.get_methods(cls, exclude=None, return_strings=True) Get all the method of a class. Arguments cls : The class to fetch the methods from. If it's a string, it should be in the dotted format. 'keras.layers.Dense' for example. exclude : The names which will be excluded from the returned list. For example, get_methods('keras.Model', exclude=['save']) . return_strings : If False, the actual methods will be returned. Note that if you use aliases when building your docs, you should use strings. This is because the computed signature uses __name__ and __module__ if you don't provide a string as input. Returns A list of strings or a list of methods.","title":"get_methods"},{"location":"documentation_generator/","text":"[source] DocumentationGenerator material_sphinx.DocumentationGenerator( pages={}, project_url=None, template_dir=None, examples_dir=None, extra_aliases=None, max_signature_line_length=110, titles_size=\"###\", ) Generates the documentation. Arguments pages Dict[str, list] : A dictionary. The keys are the files' paths, the values are lists of strings, functions /classes / methods names with dotted access to the object. For example, pages = {'my_file.md': ['keras.layers.Dense']} is valid. project_url Optional[Union[str, Dict[str, str]]] : The url pointing to the module directory of your project on GitHub. This will be used to make a [Sources] link. template_dir : Where to put the markdown files which will be copied and filled in the destination directory. You should put files like index.md inside. If you want a markdown file to be filled with the docstring of a function, use the {{autogenerated}} tag inside, and then add the markdown file to the pages dictionary. example_dir : Where you store examples in your project. Usually standalone files with a markdown docstring at the top. Will be inserted in the docs. extra_aliases Optional[Union[List[str], Dict[str, str]]] : When displaying type hints, it's possible that the full dotted path is displayed instead of alias. The aliases present in pages are used, but it may happen if you're using a third-party library. For example tensorflow.python.ops.variables.Variable is displayed instead of tensorflow.Variable . Here you have two solutions, either you provide the import material-sphinx should follow: extra_aliases=[\"tensorflow.Variable\"] , either you provide a mapping to use extra_aliases={\"tensorflow.python.ops.variables.Variable\": \"tf.Variable\"} . The second option should be used if you want more control and that you don't want to respect the alias corresponding to the import (you can't do import tf.Variable ). When giving a list, material-sphinx will try to import the object from the string to understand what object you want to replace. max_signature_line_length int : When displaying class and function signatures, material-sphinx formats them using Black. This parameter controls the maximum line length of these signatures, and is passed directly through to Black. titles_size : \"#\" signs to put before a title in the generated markdown. [source] generate DocumentationGenerator.generate(dest_dir) Generate the docs. Arguments dest_dir : Where to put the resulting markdown files.","title":"Documentation generator"},{"location":"documentation_generator/#documentationgenerator","text":"material_sphinx.DocumentationGenerator( pages={}, project_url=None, template_dir=None, examples_dir=None, extra_aliases=None, max_signature_line_length=110, titles_size=\"###\", ) Generates the documentation. Arguments pages Dict[str, list] : A dictionary. The keys are the files' paths, the values are lists of strings, functions /classes / methods names with dotted access to the object. For example, pages = {'my_file.md': ['keras.layers.Dense']} is valid. project_url Optional[Union[str, Dict[str, str]]] : The url pointing to the module directory of your project on GitHub. This will be used to make a [Sources] link. template_dir : Where to put the markdown files which will be copied and filled in the destination directory. You should put files like index.md inside. If you want a markdown file to be filled with the docstring of a function, use the {{autogenerated}} tag inside, and then add the markdown file to the pages dictionary. example_dir : Where you store examples in your project. Usually standalone files with a markdown docstring at the top. Will be inserted in the docs. extra_aliases Optional[Union[List[str], Dict[str, str]]] : When displaying type hints, it's possible that the full dotted path is displayed instead of alias. The aliases present in pages are used, but it may happen if you're using a third-party library. For example tensorflow.python.ops.variables.Variable is displayed instead of tensorflow.Variable . Here you have two solutions, either you provide the import material-sphinx should follow: extra_aliases=[\"tensorflow.Variable\"] , either you provide a mapping to use extra_aliases={\"tensorflow.python.ops.variables.Variable\": \"tf.Variable\"} . The second option should be used if you want more control and that you don't want to respect the alias corresponding to the import (you can't do import tf.Variable ). When giving a list, material-sphinx will try to import the object from the string to understand what object you want to replace. max_signature_line_length int : When displaying class and function signatures, material-sphinx formats them using Black. This parameter controls the maximum line length of these signatures, and is passed directly through to Black. titles_size : \"#\" signs to put before a title in the generated markdown. [source]","title":"DocumentationGenerator"},{"location":"documentation_generator/#generate","text":"DocumentationGenerator.generate(dest_dir) Generate the docs. Arguments dest_dir : Where to put the resulting markdown files.","title":"generate"}]}